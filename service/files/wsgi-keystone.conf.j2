{% set venv_path = '/var/lib/microservices/venv/lib/python2.7/site-packages' %}

{% if keystone.tls.enabled %}
Listen 127.0.0.1:{{ keystone.public_port.cont }}
Listen 127.0.0.1:{{ keystone.admin_port.cont }}
{% else %}
Listen {{ keystone.public_port.cont }}
Listen {{ keystone.admin_port.cont }}
{% endif %}

{% if keystone.tls.enabled %}
<VirtualHost 127.0.0.1:{{ keystone.public_port.cont }}>
{% else %}
<VirtualHost *:{{ keystone.public_port.cont }}>
{% endif %}
    WSGIDaemonProcess keystone-public processes={{ keystone.wsgi.processes }} threads={{ keystone.wsgi.threads }} user=keystone group=keystone display-name=%{GROUP} python-path={{ venv_path }}
    WSGIProcessGroup keystone-public
    WSGIScriptAlias / /var/www/cgi-bin/keystone/public
    WSGIApplicationGroup %{GLOBAL}
    WSGIPassAuthorization On
    ErrorLogFormat "%M"
    LogFormat "%{X-Forwarded-For}i %l %u %t \"%r\" %>s %b %D \"%{Referer}i\" \"%{User-Agent}i\"" access
    # w00t? Well, we want keystone to log to stdout, for heka stuff, so docker logs could see it, for example.
    # In docker env only the pid 1 stdout\err logs are passing to docker, so we need this hack,
    # since the pid 1 in this case is a dumb init. FIXME in future.
    ErrorLog /proc/1/fd/2
    CustomLog "/var/log/ccp/keystone/keystone-access.log" access
</VirtualHost>

{% if keystone.tls.enabled %}
<VirtualHost 127.0.0.1:{{ keystone.admin_port.cont }}>
{% else %}
<VirtualHost *:{{ keystone.admin_port.cont }}>
{% endif %}
    WSGIDaemonProcess keystone-admin processes=5 threads=1 user=keystone group=keystone display-name=%{GROUP} python-path={{ venv_path }}
    WSGIProcessGroup keystone-admin
    WSGIScriptAlias / /var/www/cgi-bin/keystone/admin
    WSGIApplicationGroup %{GLOBAL}
    WSGIPassAuthorization On
    ErrorLogFormat "%M"
    LogFormat "%{X-Forwarded-For}i %l %u %t \"%r\" %>s %b %D \"%{Referer}i\" \"%{User-Agent}i\"" access
    # Check the comment above.
    ErrorLog /proc/1/fd/2
    CustomLog "/var/log/ccp/keystone/keystone-access.log" access
</VirtualHost>
